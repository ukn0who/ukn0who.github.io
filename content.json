{"meta":{"title":"P1ayground","subtitle":null,"description":null,"author":"Uknowho","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"C 语言- 输出有符号, 无符号类型范围","slug":"C 语言- 输出有符号无符号类型范围","date":"2018-10-21T12:41:16.000Z","updated":"2018-10-21T14:19:48.789Z","comments":true,"path":"2018/10/21/C 语言- 输出有符号无符号类型范围/","link":"","permalink":"http://yoursite.com/2018/10/21/C 语言- 输出有符号无符号类型范围/","excerpt":"","text":"问题描述:在&lt;C语言程序设计&gt;中, 其中一个问题是: 编写一个程序分别确定有符号 (signed) 和无符号 (unsighed) 限定的 char int short long 类型的取值范围. 一种方式就是直接输出定义在 limits.h 头文件中的各种类型宏.例如 123456789#include &lt;stdio.h&gt;#include &lt;limits.h&gt;/* signed */printf(\"signed char min = %d\\n\", SCHAR_MIN);printf(\"signed char max = %d\\n\", SCHAR_MAX);/* unsigned */printf (\"unsigned char max = %d\\n, UCHAR_MAX\"); //无符号类型的值最小值都是 0 另一种方式是直接计算, 不使用定义好的头文件. 12345678# include &lt;stdio.h&gt;/* signed */printf(\"signed char min = %d\\n\", ~(char)(unsigned char) ~0 &gt;&gt; 1);printf(\"signed char max = %d\\n\", (char)(unsigned char) ~0 &gt;&gt; 1);/* unsigned */printf(\"unsigned char max = %u\", (unsigned char) ~0); 对于有符号类型范围计算的解释是; 先将 0 的各个位取反.即 [0….00] 变为 [1…11]. ~0 强制类型转换为 unsigned char. (unsigned char) ~0 右移 1 个单位, 用来去除符号位. (unsigned char) ~0 &gt;&gt; 1 右移之后, 最高位会用 0 填充. 在 signed 类型的解释中, 最高为位(符号位)为 0 , 解释为正数. 最后转为 char 类型 (signed). 即为有符号 char 的最大值 (char)(unsigned char) ~0 &gt;&gt; 1 思路总结大家都知道在计算机中是以 二进制 方式存储信息. 对于非负数, 即unsigned类型, 其最小值 $ U_{min}$ 等于所有位取值为 $0$ 时. 即 $U_{min} = 0$. 其最大值 $U_{max}$ 等于所有位取值为 $1$ 时, 即 $U_{max} = 2^w$, $w$ 代表类型所占的位数(bits). 而对于负数, 由于最高位用作符号位 所以用来表示数的范围的位数比总位数少 $1$ . 即对于 8 位类型的有符号(signed) 数, 真正表示数值的 只有 7 位. 所以对于负数的最大值是$S_{max} = 2^{8-1} = 127$ , 所以当符号位为 0, 其余数值各位取 1 , 即位表示为[01….1]时, 有符号类型有最大值. 最小值等于对最大值取反,即 $S_{min} =$ ~ $S_{max}$ 疑问为什么对于有符号数来说, 最大值取反就是最小值呢? 请看这里的解释:","categories":[],"tags":[]},{"title":"C语言 - 枚举类型","slug":"C语言 - 枚举类型","date":"2018-10-17T13:01:41.000Z","updated":"2018-10-21T14:17:33.373Z","comments":true,"path":"2018/10/17/C语言 - 枚举类型/","link":"","permalink":"http://yoursite.com/2018/10/17/C语言 - 枚举类型/","excerpt":"","text":"枚举类型是什么枚举(enum)是一个描述 常量整型值的列表(或叫集合)的类型 由于枚举被当作一种类型, 所以枚举的使用方式可以模仿C语言基本变量: (char int float double, 4种基本变量) 123456/*基本变量使用方式*/int v = 1;/*enum使用方式*/enum boolean &#123;NO, YES&#125;; 可以这样理解这个定义enum boolean {NO, YES}; enum : 声明一个枚举(enum). boolean: 给枚举起个名称, 当然也可以不起这个名称, 所以 enum后面的名称是可以省略的,. 名称boolean实际上指代的是enum {NO, YES} 这个整体部分.(人们都是懒惰的, 谁不想用boolean去代替每次输入enum {NO, YES}的麻烦呢?) {NO, YES}: 枚举的值 enum的另一个治疗懒惰的方式就是”让你不去做这件事”.所以枚举(enum)会自动赋值. 规则是: 没有显示说明的情况下, enum类型中的第一个值为 0, 第二个值为 1, 第三个值为 2. …以此类推. 如果指定了部分(没有人会从中间指定), 未指定的部分将按照最后一个枚举的值, 依次递增, 12enum weeks &#123;MON = 1, TUES, WED, THUR, FRI, SAT, SUN&#125;;/* TUES 就等于 2 了 */ 枚举变量声明方式虽然enum boolean {NO, YES}; 定义起来很简单, 但在代码中经常还会出现其他形式的声明或定义. 123456789101112/*第一种, 直接声明变量*/enum boolean &#123; NO, YES&#125;,okboolean;/*第二种, 间接声明变量*/enum boolean &#123; NO, YES&#125;;enum boolean okboolean; 跟C语言中的结构体几乎一样. 还有很多使用 typedef 的. 跟这两种实际上没有差别.需要记住的是: 定义enum的别名是可以省略的.就算使用typedef也是一样. enum {...}这个整体是一种类型, 带别名或不带别名都没有差别, 都要当作一个整体. 在枚举定义完之后 (即 反中括号 }后面) 是枚举变量名, 可以想象enum {} 这个整体就是 int , (或者其他类型) 跟在后面就是变量名. 枚举有什么用 我觉得还是因为懒. 人们原来使用#define每次都要一个#define 定义一个常量 写一个值. 枚举的出现很大可能就是为了解决不用多次输入这个问题. 所以从功能上来讲, enum 和 #define 没有区别. 枚举和#define相比 最大的优势在于常量的值可以自动生成. 根据一书的说法, 对于enum的变量, 编译器不会去检查这个变量被赋予的值是不是在枚举列表中存在, 但是枚举类型本身却可以提供这种检查. 换句话说枚举变量只能使用定义时列表内的值, 用上面的例子来解释的话 okboolean 这个枚举变量在赋值时, 只能使用 NO 或 YES 来赋值 因此枚举比#define更有优势.","categories":[],"tags":[]},{"title":"C语言 - 常量、转义字符","slug":"C语言 - 常量","date":"2018-10-07T01:46:35.000Z","updated":"2018-10-21T14:18:20.109Z","comments":true,"path":"2018/10/07/C语言 - 常量/","link":"","permalink":"http://yoursite.com/2018/10/07/C语言 - 常量/","excerpt":"","text":"常量表达式,在编译时求值. 带后缀的常量 带后缀的整数 long 类型的常量通常以 l 或 L 结尾, 例如 1234L. unsigned 以 u 或 U 结尾. ul 或 UL 代表 unsigned long 类型 带后缀的浮点数 浮点数通常带有小数点(12.3)或指数(1e-2). 后缀 f 或 F 表示 float.类型. 后缀 l 或 L 表示 long double 类型. 带前缀的常量八进制整数表示, 以 0 为前缀. 如 037~Octal~ 代表十进制 31~Decimal~ 十六进制整数表示,以 0x 或 0X 为前缀, 如0x1f ~Hex~或 0x1F~Hex~ 八进制和十六进制常量也可以使用 L 和 U 代表 long 和 unsigned 如 0xFUL~Hex~ 等于十进制1~Decimal~ 字符常量字符本质上是一个整数, 需要用单引号括起来. ‘\\0’ 表示空字符(null) 转义字符\\a 响铃 \\\\ 反斜杠 \\b 回退 \\? 问号 \\f 换页 \\‘ 单引号 \\n 换行 \\“ 双引号 \\r 回车 \\ooo 八进制数 (替换ooo) \\t 横向制表符 \\xhh 十六进制数 (替换hh) \\v 纵向制表符","categories":[],"tags":[]},{"title":"C语言 - 数据类型及长度","slug":"C语言 - 数据类型及长度","date":"2018-10-07T01:16:52.000Z","updated":"2018-10-21T14:19:07.371Z","comments":true,"path":"2018/10/07/C语言 - 数据类型及长度/","link":"","permalink":"http://yoursite.com/2018/10/07/C语言 - 数据类型及长度/","excerpt":"","text":"基本类型C 语言只提供 4 种基本类型: char 字符型, 占 1 字节 (Byte), 存放本地字符集.[^1] int 整形, 具体长度和机器相关. float 单精度浮点型. double 双精度浮点型. short 与 longshort 与 long 只用于限定 int 类型. short 和 int至少 16 位, long 至少 32 位. short 不能长于 int . int 不能长于 long . signed 与 unsignedsigned 与 unsigned 用于限定 char 或 任何类型 . unsigned 用于是大于 0 的. signed 与 signed 取值范围取值范围遵循 $2^n$. 比如 char 占 8 位, 则 unsigned 取值范围为 0~255, signed 为 -128 ~ +127. [^1]: 字符本质上是一个整数, 具体定义跟字符集有关, 可以通过命令 ascii 在Linux上查看ASCII字符集.","categories":[],"tags":[]},{"title":"C语言 - 命名规则","slug":"C语言 - 命名规则","date":"2018-10-07T00:48:44.000Z","updated":"2018-10-21T14:16:38.459Z","comments":true,"path":"2018/10/07/C语言 - 命名规则/","link":"","permalink":"http://yoursite.com/2018/10/07/C语言 - 命名规则/","excerpt":"","text":"变量名使用小写字母 常量全部使用大写字母 局部变量名尽量短, 外部变量名称较长 尽量不要使用下划线 “_” 开头的名字, 因为大多数库例程都是以下划线开头.内部名称 的有效长度至少为 31 .外部名称ANSI仅保证前6个字符唯一","categories":[],"tags":[]}]}